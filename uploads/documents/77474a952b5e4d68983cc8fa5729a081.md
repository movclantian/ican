[TOC]



# C语言笔记

## C语言基础知识

---

#### 简单的C语言程序

```c
/*输出Hellow world*/
#include<stdio.h>
int main(){
printf("hellow world");
}
```

- ==main是一个特殊的函数名，称为主函数。==花括号中的内容是main（）的函数体，由若干条语句组成，每个语句最后的分号代表这个语句结束。
- ==一个C语言程序由若干个函数组成，其中必定有唯一的main（）函数。==
- printf函数是C语言的标准库函数，该函数原型在标准库的头文件<stdio.h>中定义，所以需要使用#include加以包含。

```c
/*计算两个整数之和*/
int main(){
	int value1,value2,sum;
    value1 = 30;
    value2 = 45;
    sum = value1 + value2;
    printf("sum = %d\n",sum);
}
```

- /* */称为注释，可帮助阅读理解程序，提高程序的可读性。没有实际的逻辑意义。
- int value1,value2,sum;用来定义这三个变量的类型为整型（int）。==C语言中的所有变量使用前必须预先定义==。程序设计语言中变量的本质是储存单元，使用变量名称访问储存单元。
- C语言中的“=”从语义上来说是赋值，既将“=”右边表达式（常量或变量是最简单的表达式）的值赋给左边的变量，也就是储存在左边变量命名的储存单元中。

```c
//输出两个整数中的较大值
#include<stdio.h>
int max(int x,int y){
	int z;
    if(x>y)
        z=x;
    else
        z=y;
    return z;
}
int main(){
	int a,b,c;
    printf("a,b=");
    scanf("%d,%d",&a,&b);
    c = max(a,b);
    printf("max=%d\n",n);
}
```

- 一个C语言程序由若干个函数组成，或者由一个主函数组成，或者由一个主函数和若干个其他函数组成。

#### 关键字和标识符

###### 一、关键字

​		关键字是**具有特定含义的、专门用来说明C语言的特定成分的一类单词**。 **C语言的关键字都是用小写字母书写的，不能用大写字母书写。关键字不能用于变量名或函数名等其 它场合**，否则会出现编译错误。 C语言定义了32个关键字。

​																C语言关键字列表

| [auto](https://baike.baidu.com/item/auto/10128?fromModule=lemma_inlink) | [break](https://baike.baidu.com/item/break/405784?fromModule=lemma_inlink) | [case](https://baike.baidu.com/item/case/7146375?fromModule=lemma_inlink) | [char](https://baike.baidu.com/item/char/5156054?fromModule=lemma_inlink) | [const](https://baike.baidu.com/item/const/1036?fromModule=lemma_inlink) | [continue](https://baike.baidu.com/item/continue/3009735?fromModule=lemma_inlink) | [default](https://baike.baidu.com/item/default?fromModule=lemma_inlink) | [do](https://baike.baidu.com/item/do/18599594?fromModule=lemma_inlink) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [double](https://baike.baidu.com/item/double?fromModule=lemma_inlink) | [else](https://baike.baidu.com/item/else?fromModule=lemma_inlink) | [enum](https://baike.baidu.com/item/enum/10934073?fromModule=lemma_inlink) | [extern](https://baike.baidu.com/item/extern?fromModule=lemma_inlink) | [float](https://baike.baidu.com/item/float/19167524?fromModule=lemma_inlink) | [for](https://baike.baidu.com/item/for?fromModule=lemma_inlink) | [goto](https://baike.baidu.com/item/goto/12755716?fromModule=lemma_inlink) | [if](https://baike.baidu.com/item/if/4529589?fromModule=lemma_inlink) |
| [int](https://baike.baidu.com/item/int/944671?fromModule=lemma_inlink) | [long](https://baike.baidu.com/item/long/412402?fromModule=lemma_inlink) | [register](https://baike.baidu.com/item/register?fromModule=lemma_inlink) | [return](https://baike.baidu.com/item/return/16284?fromModule=lemma_inlink) | [short](https://baike.baidu.com/item/short?fromModule=lemma_inlink) | [signed](https://baike.baidu.com/item/signed?fromModule=lemma_inlink) | [sizeof](https://baike.baidu.com/item/sizeof?fromModule=lemma_inlink) | [static](https://baike.baidu.com/item/static?fromModule=lemma_inlink) |
| [struct](https://baike.baidu.com/item/struct?fromModule=lemma_inlink) | [switch](https://baike.baidu.com/item/switch/18601752?fromModule=lemma_inlink) | [typedef](https://baike.baidu.com/item/typedef?fromModule=lemma_inlink) | [union](https://baike.baidu.com/item/union/1974872?fromModule=lemma_inlink) | [unsigned](https://baike.baidu.com/item/unsigned?fromModule=lemma_inlink) | [void](https://baike.baidu.com/item/void/5126319?fromModule=lemma_inlink) | [volatile](https://baike.baidu.com/item/volatile?fromModule=lemma_inlink) | [while](https://baike.baidu.com/item/while?fromModule=lemma_inlink) |

######  二、标识符

**标识符是指用来表示变量名、符号常量名、函数名、数组名、类型名、文件名的字符序列。**
**C语言标识符的命名规则**：
==1.首字符必须是字母或下画线。==
==2.只能包含字符A\~Z、a\~z、0~9及（下画线）。==
==3.标识符不能是关键字==
==4.标识符不能跨行书写。==
关于标识符的几点说明：

 (1)选择具有一定意义的英文单词做标识符。例如，用day表示日期、sum表示和等。
(2)适当地使用下画线。例如，用load num表示调入数据等。
(3)使用约定俗成的标识符。例如，temp表示中间变量，x、y和z表示需要计算的变量等。
(4)标识符的长度不要过长。
(5)用大小写区别命名。例如，loadnum和loadNum是两个不同的标识符，后者则相
对易于阅读。C语言程序中，通常变量使用小写字符开头的标识符，而符号常量往往使用大写字符的标识符。

 正确标识符命名：    smart    _decision   high3   Area
      不正确标识符命名：5smart(以数字开头)
                                      Bomb?(含有特殊字符？)
                                      High.balance(把下划线“\_”与“.”混淆)  
                                      float（不能用C语言中的关键字）

----

----

---



#### C语言数据类型

![C语言数据类型](https://img-blog.csdnimg.cn/202009241406392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4MjAzNg==,size_16,color_FFFFFF,t_70#pic_center)

###### 一、整型（int）

**==1、有符号整型==**

​		**有符号整型的数据类型通常包括 int、short、long、long long 四种**，因为是有符号类型，所以前面要加上 signed ，但是通常省略，也就是说==在代码中直接打出 int 类型就代表是有符号类型的。==

（1）int类型
**数据类型大小是 4 字节**，能表示的数值范围是
-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）
打印类型是 %d ，使用格式为 int 名 = 值;

（2）short类型
**数据类型大小是 2 字节**，能表示的数值范围是
-2^(16-1) – 2(16-1) -1 （即 -32768 ~ 32767）
打印类型是 %hd ，使用格式为 short 名 = 值;

（3）long类型
**数据类型大小是 4 字节**，能表示的数值范围是
-2^(32-1) – 2^(32-1)-1 （即 -2147483648 ~ 2147483647）
打印类型是 %ld ，使用格式为 int 名 = 值;

（4）long long类型
**数据类型大小是 8 字节**，能表示的数值范围是
-2^(63) ~ 2^(63)-1 (这个数足够大了)
打印类型是 %lld ，使用格式为 long long 名 = 值;

==**2、无符号整型**==

​		==无符号数用 unsigned 表示 ，只表示数据量，而没有方向（没有正负，且无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。==

（1）unsigned int 类型
数据类型大小是 4 字节，能表示的数值范围是
0 – 2^(32）-1 （即 0~4294967295）
打印类型是 %u ，使用格式为 unsigned int 名 = 值;

（2）unsigned short 类型
数据类型大小是 2 字节，能表示的数值范围是
0 ~ 2^8 -1 （即 0~65535）
打印类型是 %hu ，使用格式为 unsigned short 名 = 值;

（3）unsigned long 类型
数据类型大小是 4 字节，能表示的数值范围是
0 – 2^(32）-1 （即 0~4294967295）
打印类型是 %lu ，使用格式为 unsigned long 名 = 值;

（4）unsigned long long 类型
数据类型大小是 8 字节，能表示的数值范围是
0~2^63-1
打印类型是 %llu ，使用格式为 unsigned long long 名 = 值;

---

###### 二、 字符型（char）

字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中**每个字符变量都会占用 1 个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(’ ')把字符括起来。char的本质就是一个1字节大小的整型。**

==字符类型的数据在内存中储存的是其ASCII码值。==

**char 的格式匹配符（打印格式) 为：%c**

数值表示范围是：
有符号: -2^(8-1) – 2(8-1) -1 （即 -128 ~ 127）
无符号： 0 ~ 2^8 -1 （即 0~255）

字符常量用单引号括起来，如'A'、'1和'$等。这些字符是可见字符，但是还有一些字
符是不可见的字符，也称为非打印字符，==无法采用类似的方式显式地书写，或者无法从键盘直接输入==。为了使程序可以处理字符集中的每一个字符，C语言提供了一种特殊的表示法—转义序列，通常称为转义符。转义符有字符转义符和数字转义符两种，字符转义符由反斜杠\加一个字母组成，如’\n‘表示换行符，数字转义符又有八进制转义符和十六进制转义符两种。

![image-20221205115617962](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221205115617962.png)

**'\ddd'是八进制转义符，ddd是八进制数（由0\~7组成）；'\xhh'是十六进制转义符，hh是十六进制数（由0\~9、a\~f或A~F组成）。==使用这两种转义符可以表示任意的ASXII字符。==**

- C语言标准库中的头文件<ctype.h>中定义了若干与字符处理有关的函数。
- 其中toupper()可以将小写字母转换成大写字母。

###### 三、浮点类型

1.==**单精度浮点型**==（float）

**单精度浮点型的大小是 4 字节**
float v1 = 4.345;
unsigned float v1 = 4.345; 无符号的 float 数据
**格式匹配符是：%f ， 默认保留 6 位小数。**

2.==**双精度浮点型**==（double）

**双精度浮点型的大小为 8 字节**
double v2 = 5.678;
unsigned double v2 = 5.678; 无符号的 double 数据

==**格式匹配符是：%lf。**==

printf(“n = %08.3f\n”, n);
**输出的含义为：显示8位数（包含小数点）， 不足8位用0填充。并且保留3位小数。对第4位做四舍五入。**

###### 四、数据类型转换

C语言的数据类型转换方式有三种：自动类型转换、赋值类型转换、和强制类型转换。前两种是隐式转换，后一种是显式转换。

下列情况会进行隐式转换：

1. 算数表达式或逻辑表达式中操作数的类型不同（C语言执行常用算数转换）。
2. 赋值运算符右侧表达式值的类型与左侧变量的类型不匹配。
3. 函数调用中的实参类型与其对应的形参类型不匹配。
4. return语句（函数返回值语句）中表达式的类型与返回值的类型不匹配。

1、==**自动类型转换**==

**在进行运算时，不同类型的数据要转换成同一类型。**自动转换的规则如图

![](https://img-blog.csdnimg.cn/18eda9402e114e618f2c559ddedfa1ff.png#pic_center)

转换方法为：

1. **float型数据自动转换成double型；**
2. **char与short型数据自动转换成int型；**
3. **int型与double型数据运算，直接将int型转换成double型**
4. **int型与unsigned型数据、直接将int型转换成unsigned型；**
5. **int型与long型数据，直接将int型转换成long型。**

二、==**赋值类型转换**==

**如果赋值运算符两侧的类型不一致，但都是数值型或字符型时，在赋值时要进行类型转换。**转换的基本原则如下。

1. 将整型数据赋给单、双精度变量时，数值不变，但以浮点数形式存储到变量中
2. 将实型数据(包括单、双精度)赋给整型变量时，舍弃实数的小数部分。如x为整型变量，执行“x=4.25”时，取值为x=4。
3. 同类型的短数据赋值给长变量，自动转换是正确的，例如，char和short型数据给int型变量赋值。
4. 同类型的长数据给短变量赋值可能出错。例如，当unsigned int型的值超过了int变量的取值范围，赋值会出错

​	例如：unsigned int 变量给int变量赋值出错

三、==**强制类型转换**==

可以利用强制类型转换运算符将一个表达式转换成所需类型。如：

```c
(double)x/*将x转换成double型*/ 
(int)(a+b)/*强制将a+b的值转换成整型*/
(float)(10%3)/*将10%3的值转换成float型*/ 
```

**强制类型转换的一般形式为：**
**（类型名）（表达式）**

**==例如：需要对一个浮点表达式f（f为浮点类型）保留小数点两位并进行四舍五入时，可以用表达式（int）（100*f + 0.5）/100.0来实现。==**

例如：

```c
int a=7,b=2;
float y1,y2;
float y1=a/b;/*y1的值a/b为3.0*/
y2=(float)a/b;/*y2的值为3.5，float将a进行强制转换为实型，b也随之自动转换为实型*/
```

---

---

---

#### C语言中的常量与变量

###### 一、常量

**==不会变化的数据，不能被修改==**

1.举例：
比如 “hello” 为字符串常量、‘A’ 为字符常量 、-10 为整型常量、3.1415926 为浮点常量；

2.宏定义

**#define PI 3.1415**
这样定义出来的 PI 也是常量，数值为3.1415；
**【强调】**在进行宏定义时，没有分号结束标记。
【推荐】 定义宏： 语法： #define 宏名 宏值

**整数常量**

C语言中，整数类型常量有十进制、八进制和十六进制三种书写形式。
(1)十进制整数常量：由正负号(+或-)和数字0~9组成，首字符不能是0。例如，128、
-98、0、100。

(2)八进制整数常量：以“0”开头，由数字0~7组成，首字符必须是0。例如，0127
表示八进制数127，即(127)g,等于十进制数87。再如，0144，等于十进制数100。

(3)十六进制整数常量：以“0x”或“0X”开头，由0\~9、a\~f或A~F组成。例如，0x1C
表示十六进制数1C,,等于十进制数28。再如，0x64,等于十进制数100。

从类型上，整数常量有一般整数常量和长整数常量两种类型。整数常量即上述介绍的
三种不同进制的整数。长整数常量是在整数常量后面加字母L或l。例如，87是整数常量，
87L是长整数常量。

**浮点数常量**

​		**浮点数常量有十进制表示法和指数表示法**，浮点数常量必须包含小数点或指数部分，
可以带正、负符号。
​		十进制表示法与数学表示没有区别，包含整数部分和小数部分，但是没有指数部分，
如**987.、-123.456、.456**。在小数点的前后至少一边有数字。
​		指数表示法包含**尾数部分和指数部分**，**尾数部分可以是整数或十进制浮点数：指数部**
**分是以字符E或e开头，后面跟一个带正、负符号的整数。**例如，-123E3表示-123×10^3^，
987.654e-10表示987.654×10^-10^。字符E或e前面的数字是底数部分。
​		从类型上，还可以使用后缀字符f或F、1或L。浮点数常量又分为以下三种。
​		(1)float型常量：后缀为f或F。例如，123.f、987.123F、123.e+3f、123.987E-3f、
12F、98f。
​		(2)double型常量：没有后缀。例如，123.、987.123、123.e+3、123.987E-3。
​		(3)long double型常量：后缀为l或L。例如，123.1、987.123L、123.e+31、123.987E-3L
需要注意的是，**123.是double型常量，123是int型常量；123.L是long double型常**
**量，123L是1ong型常量，它们的区别就在那个小数点上。**

**字符常量**

字符常量是用单引号括起来的单个字符。例如，'A'、'g'、'?'、'6'都是字符常量。注意，
==其中的单引号不是字符常量的一部分，只起分隔作用，称为字符常量定界符。==
另外，**转义符也是字符常量的一种特殊表示形式例如，'\101'或'x41'
表示字符'A','\010'或'x08'表示退格，'0'或'x0'表示空字符(NULL)。实际上，用八进制**
**转义符或十六进制转义符可以表示任何字符。**

**字符串常量**

字符串常量是用一对双引号引起来的零个或多个字符序列。

字符串常量在C语言中被处理为一维字符数组存储在内存中一块连续的区域。
字符串和字符串数组在内存中的形式基本一致，唯一的区别就是字符串的末尾多了一个’\0’。’\0’就是值为0的ASCII码，其在字符串中作为字符串终止符。

==字符串的内存空间字符数=有效内容占字符数+1（多以1字节的终止符）==

###### 二、变量

==**会变化的数据，能被修改**==

1、常用的定义变量的语法为：

**类型名 变量名 = 变量值**

**变量三要素：类型名、变量名、变量值。**

举例：int r = 3; float s = PIrr;(变量值是一个表达式)

变量定义的一般形式为：**数据类型 变量名;**

多个类型相同的变量：**数据类型 变量名, 变量名, 变量名...;**

==变量名列表是由逗号（，）分隔开的若干变量或含有初始化的变量。每一个变量名必须是一个合法标识符，并且不能同名。==

```c
int x = 10,y;
```

==**注意：不能写成**==

```c
int a=b=c=6;
```



![](https://img.mukewang.com/5492b58f0001043803840131.jpg)

2、变量的定义与声明：

变量的定义：
int a = 40;

变量的声明：
int a; 没有变量值的变量定义 叫做声明。

注：变量定义会开辟内存空间，但是变量声明不会开辟内存空间。变量要想使用必须有定义。当编译器编译程序时，在变量使用之前，必须要看到变量定义。如果没有看到变量定义，编译器会自动找寻一个变量声明提升成为定义。但是如果该变量的声明前有 extern 关键字，无法提升。
还有，在定义变量时，尽量不要重名。

***注意:在定义中不允许连续赋值，如int a=b=c=5;是不合法的。***

变量的赋值分为**两种方式**：1.**先声明再赋值** 2.**声明的同时赋值**，例如：

![](https://img.mukewang.com/550aa8d000017f4202330103.jpg)

**字符串变量**
字符串变量实际上就是一维字符数组。
初始化字符串变量的方法：

```
char str[13] = {"Good Day!"};
char array[20] = "\0";
```

使用printf函数可以实现字符串的格式化输出，其为字符串输出提供了专门的格式符：%s。

对于字符串的格式化输入的形式如下：

```
scanf("%s",str);
```

**由于数组名就代表数组的首地址，因此，该语句中不需要对str取地址。**

###### 原码 反码 补码

==带符号整型数据在储存单元中是以补码形式储存的==

**原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负**

**反码：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反**

**补码：正数的补码是其本身，负数的补码是在其反码的基础上+1**

---

---

---

#### C语言运算符

C语言运算符按其功能分为：算术运算符、关系运算符、逻辑运算符、赋值运算符位运算符、递增递减运算符等。按参与运算的操作数个数分为：单目运算符、双目运算符和三目运算符。

![image-20221206174523632](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221206174523632.png)

##### 一、算数运算符

C语言基本算术运算符如下表：

![](https://img.mukewang.com/54ac8dfb000126ad04510145.jpg)

**除法运算中注意：**

如果相除的**两个数都是整数**的话，则**结果也为整数**，小数部分省略，如8/3 = 2；而两数中**有一个为小数**，**结果则为小数**，如：9.0/2 = 4.500000。

**取余运算中注意：**

该运算**只适合用两个整数**进行取余运算，如：10%3 = 1；而10.0%3则是错误的；运算后的符号取决于被模数的符号，如(-10)%3 = -1;而10%(-3) = 1。

---

##### 二、自增自减运算符

自增运算符为“++”，其功能是使变量的值自增1；自减运算符为“--”，其功能是使变量值自减1。它们经常使用在循环中。自增自减运算符有以下几种形式：

==自增自减运算符的运算对象必须是变量或储存单元，不能是常量或表达式==，如果写成6++或（a+b）++都是错误的。

![](https://img.mukewang.com/548043a400012aa904320091.jpg)

**【注意】：i++表达的是变量i增1之前的值，i--表达的是变量i减1之前的值。++i表达的是变量i增1之后的值，--i表达的是变量i减1之后的值**

---

##### 三、赋值运算符

简单的赋值运算符“=”，如：

![](https://img.mukewang.com/5492bd4700016e9103370083.jpg)

由赋值运算符“=“构成的赋值表达式的一般形式为：

v = e

其中，v是变量或储存单元，e是表达式。其语义是对赋值运算符右边的表达式e进行求值，将表达式e的值储存到赋值运算符左边的变量或储存单元v中。

**==赋值表达式也有值，赋值表达式的值就是赋值给变量的值==**

**==复合赋值运算符==**

算数运算符（+、-、*、/。%）和位运算符（&、|、^、<<、>>）与赋值运算符组合构成复合赋值运算符。复合赋值运算符有如下十个。

+=	-=	*=	/=	%=	&=	|=	^=	<<=	>>=

![](https://img.mukewang.com/5492bd7600016d2603370038.jpg)

**分析：定义整型变量a并赋值为3，a += 5;这个算式就等价于a = a+5; 将变量a和5相加之后再赋值给a**

**==由复合赋值运算符构成的表达式的一般形式为：==**

**==v op = e==**

它相当于：

**==v = (type) (v op e)==**

**==其中，type是v的类型，（type）是强制类型转换，将表达式（v op e）的值转换为v的类型的值；v是变量或储存单元；op是双目运算符，可以是算数运算符（+、-、*、/。%）和位运算符（&、|、^、<<、>>）；e是表达式。其语义是对表达式（type）（v op e）进行求值，将结果送到变量或储存单元v中。==**

**对于x +=1这样的语句，可以用x = x + 1完成，但是如果写成后者需要用两条指令来完成，一条是加法指令，另一条是数据传输指令。**

**==赋值运算符的结合性==**

**赋值运算符是右结合的，即同级运算从右至左进行计算。**例如，对于表达式a=b=c=0来说，等价于a=(b=(c=0)),其语义是先将0赋值给变量c,表达式(c=0)的值为0，再把表达式(c=0)的值赋值给变量b,最后把表达式(b=(c=0))的值赋值给变量a。这样的表达式求值过程与人们对该表达式含义的理解是一致的，即把常量0赋值给变量a、b和c。

==示例：==

```c
int i =6,j=4,k=2;
i-=j-=k;//等价于
```

```c
i-=(j-=k);
```

**运行后，变量k的值为2（不变），变量j的值为2，变量i的值为4。**

**==左值==**

==左值表示计算机内存中的存储对象，即储存单元，而不是常量或计算结果。==

**赋值运算符要求它的左操作数必须是左值。而其他运算符允许它的操作数是常量，变量或表达式**

例如：有定义语句：int a，*p;那么a，\*p和\*(p+1)都是左值。

##### 四、关系运算符：

C语言中的关系运算符：

![](https://img.mukewang.com/5481551100017fbe04250141.jpg)

***关系表达式的值是“真”和“假”，在C程序用整数1和0表示。***

**关系运算符都是双目运算符，其结合性均为左结合。**

##### 五、逻辑运算符

7<x<100这样的公式，意思是x大于7并且x小于100。

在程序中这样写一个变量的范围值是不行的，计算机是看不懂这样的算式的，那么怎样让计算机看懂呢？这里就要用到逻辑运算符了。

下面我们看一下C语言中的逻辑运算符：

![](https://img.mukewang.com/54816483000195a203180087.jpg)

**那么前面的那个算式写成计算机可以看的懂的算式就是：x>7 && x<100;**

逻辑运算的值也是有两种分别为“真”和“假”，C语言中用整型的1和0来表示。其求值规则如下：

其中，与运算符（&&）和或运算符（||）均为双目运算符，具有左结合性

==**1.与运算(&&)**==

参与运算的**两个变量都为真**时，**结果才为真**，否则为假。例如：5>=5 && 7>5 ，运算结果为真；

==**2.或运算(||)**==

参与运算的两个变量**只要有一个为真**，**结果就为真**。 两个量都为假时，结果为假。例如：5>=5||5>8，运算结果为真；

==**3.非运算(!)**==

参与运算的变量**为真时**，结果**为假**；参与运算量**为假时**，结果**为真**。例如：!(5>8)，运算结果为真。

**==虽然C语言程序在给出逻辑运算符时，以“1”代表“真”，“0”代表“假”。但反过来在判断一个量是“真”还是“假”时，以“0”代表“假”，以“非0”代表”真“。==**

**==例如：5||0的值为“真”，即为1。==**

注意：**==逻辑表达式求值时，若前面的操作数（左操作数）能够确定表达式的值，则后面的==**
**==操作数将不再求值。**对于逻辑与(&&)运算，若左操作数为假，则结果为假，右面的操作数不再求值。对于逻辑或(||)运算，若左操作数为真，则结果为真，右面的操作数不再求值。
**设x=1,y=2,z=3,则逻辑表达式(x>y)&&(z++)的值为0（假），且z的值不变。这是因为关系表达式x>=y的值为0，根据逻辑与的运算特点将不再对表达式z++求值。**

##### 六、逗号运算符

语法上，C语言中的逗号是一个运算符，本身没有语义。

**逗号运算符的功能是将两个或多个表达式联系起来。它的结合性是左结合的，所以从左至右计算各个表达式，整个表达式的值为最右边的子表达式的值。逗号运算符是所有运算符中最低的运算符。**

**逗号运算符构成表达式的一般形式为：**

==表达式1，表达式2，表达式3，···，表达式n==

其中n最小为2。

例如：

```c
int a = 3,b = 4,c =6;
int w,x,y,z;
w = ((x = a+b),(y = b+c),(z = c+a));
```

**运行后，变量x的值为7，变量y的值为10，变量z的值为9，变量w的值为9，变量w与最右边的子表达式的值相同。**

如果没有大括号，则变量w的值为7而不是9，如下：
```c
w = (x = a+b),(y = b+c),(z = c+a);,
```

##### 七、条件运算符（三目运算符）

条件运算符是C语言中唯一的三木位运算符。

C语言中的三目运算符：“?:”，其格式为：

 **表达式1 ? 表达式2 : 表达式3;** 

条件运算符的语义是：

**如果表达式1为真，则表达式2的值就是整个表达式的值，否则表达式3的值是整个表达式的值。条件运算符的运算优先级高于赋值运算符和逗号运算符。**

**【非常重要！！！】三目运算符如果输出表达式1和表达式2，那么表达式1和表达式2数值的类型是相同的**

![](https://img.mukewang.com/5492be2d0001946603740216.jpg)

##### 七、求字节运算符（sizeof）

求字节运算符sizeof是一个单目运算符，**该操作符的操作数是数据类型、变量名、数组名和结构体类型等。当操作数是数据类型时，使用该运算符可以求得该类型数据的储存单元字节数。**

由字节运算符sizeof构成表达式的一般形式为：**sizeof（类型 符或变量名）**

##### 八、运算符优先级比较

![](https://img.mukewang.com/54817fa90001654403370200.jpg)

---

---

---

---

---

---

## C语言程序控制结构

#### C语言语句概述

###### 1、表达式语句

**表达式语句由表达式加上分号“；”组成**

形式为：**表达式;**

==注意：**分号是C语言中语句结束的标志，一个语句必须以分号结束，没有分号，则不是语句。**==

###### 2、函数调用语句

**函数用语句由函数调用加上分号“；”组成**

形式为：**函数名（参数列表）；**

###### 3、空语句

**只有一个分号的语句称为空语句。它的一般形式为：**

```c
	;
```

**空语句是什么也不做的语句，可以作为循环语句中的循环体，表示循环体什么也不做。**

#### 数据输入输出

scanf和printf是函数名，而不是关键字。

最基本的输入/输出函数有四个：(1)字符输入/输出函数getchar()和putchar();	(2)格式输入/输出函数scanf()和printf()。

###### 字符输入/输出函数

**getchar()**

**putchar(字符型或整型数据)**

**getchar()函数的功能是从键盘录入一个字符，函数的值即为读取的字符，可以将函数的值赋给一个字符变量。**

```c
char ch;
ch = getchar();
```

putchar()函数的功能是向显示器屏幕输出一个字符。要输出的字符写在其后的圆括号中，可以是字符变量、变量或表达式，也可以是转义符，还可以是整数。

==注意：getchar()函数的功能是从键盘读取一个字符，**连续使用getchar（）读取多个字符时，键盘录入的所有字符都是有效字符。**==

示例：

```c
char c1,c2,c3;
c1 = getchar();
c2 = getchar();
c3 = getchar();
```

==若执行上述程序，若输入:ABC(回车)，则变量c1，c2，c3的值依次为'A','B' ,'C';若输入：A B C(空格)则变量c1，c2，c3的值依次为'A',' ' ,'B';。==

###### 标准格式化输出函数

**printf（格式控制串，输出项表）**

1. ==**格式控制串是用双引号括起来的字符串，它包括格式说明和普通字符两方面。格式说明由“%”和格式字符组成**，如%d，%f等，其作用是指定输出数据的格式，实际输出时，该部分由输出列表中相应的输出项代替。**普通字符是希望原封不动输出的字符**，其作用是说明，标注。==
2. ==**输出项表中各输出项之间用逗号分隔。**==输出项可以是常量、变量或表达式。格式说明的个数应和输出项的个数相同，且数据类型要对应一致。

printf()函数格式说明及其作用

![image-20221207145248571](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221207145248571.png)

格式修饰符：如%ld 、%5d、%#d中的#就是格式修饰符。

![image-20221207151205890](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221207151205890.png)

###### 标准格式化输入函数

**scanf（格式控制串，地址列表）**

**==功能：从键盘上按格式控制串指定的格式输入一组数据，依次存放在地址表列所指定的储存单元中。==**

**格式说明：**

![image-20221207151738710](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221207151738710.png)

**格式修饰符：**

![image-20221207151810324](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221207151810324.png)

- **==在格式控制串中，如果没有格式说明之外的字符，则输入的数据之间用空格、制表键或回车分隔。==**

- **==如果在格式控制串中含有格式说明以外的普通字符，输入数据时，这些字符不会显示到屏幕上，而是要求将这些普通字符也原样输入。==**

  **示例：**

  ```c
  scanf("%d,%d",&X,&y);
  ```

  **在输入时，就要输入3，6**

- **可以指定输入数据的宽度，系统自动截取所需的数据长度。**

  ```c
  scanf("%2d%3d",&a,&b);
  ```

  输入12345时，系统自动将12作为第一个数据，赋给a，将345赋给b。

- **使用“%c”格式输入字符时，输入的空格或转义符都是有效的字符。**

  当输入a b c时，系统将字符a赋给x，将空格字符赋给y，将字符b赋给z。

- **scanf函数读取从键盘输入的数据时，若遇到与格式要求不一致的字符，则认为与该格式对应的数据结束**

  例如：

  ```
  scanf("%d%c%f",&a,&b,&c);
  ```

  输入1234a1234.5

  格式控制串中的%d要求输入连续的数字，在读取1234后遇字母a,整数读取结束，将1234保存在变量a中；%c要求读取一个字符，将字符a保存在变量b中；其后的1234.5按%f格式读取，保存在变量c中。

---

---

---

#### 分支语句之     if语句

###### 一、if(…) {…}

1.一般形式：
if (表达式) {语句;}

表达式：
（1）用非 0 值表示真，用 0 表示假;
（2）if(flag) 相当于 if(flag!=0);
（3）浮点数无法与 0 比较，只能用近似的值比较；例: 1e-6 等于1x10的-6次方可以看成0来使用；

2.用于单分支选择结构;
3.如含有交叉关系，使用并列的if语句;

###### **二、if(…) {…} else {…}**

1. 一般形式：` if(表达式) {语句1; } else { 语句2;}`
2. 用于双分支控制的条件语句;
3. 用于非此即彼的关系时;

三、if(…) {…} else if(…) {…} … else if(…) {…} else {…}

一般形式：
if(表达式1) { 语句1;}
else if(表达式2) {语句2;}
…
else if(表达式n){语句n;}
else{语句n+1;}

---

---

---

#### switch语句

1. 一般形式：
   **switch(表达式)**
   **{**
   **case 常量1:语句1;**
   **case 常量2:语句2;**
   **…**
   **case 常量n:语句n;**
   **default: 语句n+1;**
   **}**

2. 用于多路选择的语句;

   switch语句相当于多个if-else语句;
   (表达式)只能是char型或者int型;
   **case 后面至少要有一个空格，常量后面是冒号**
   (表达式)与 常量类型要保持一致;
   记得记得记得 ***在需要跳出的时候，在语句后面加上break;***

---

---

---

#### while和dowhile语句

###### while循环的一般形式

```c
while(表达式){
    语句块;
}
```

意思是，**先计算“表达式”的值，当值为真（非0）时， 执行“语句块”；执行完“语句块”，再次计算表达式的值，如果为真，继续执行“语句块”……这个过程会一直重复，直到表达式的值为假（0），就退出循环，执行 while 后面的代码**。

**我们通常将“表达式”称为循环条件，把“语句块”称为循环体，整个循环的过程就是不停判断循环条件、并执行循环体代码的过程。**

###### do-while循环的一般形式

```c
do{
    语句块
}while(表达式);
```

**注意while(i<=100);最后的分号;，这个必须要有。**

---

---

---

#### for循环

###### for循环的一般形式

```c
for (语句1;表达式;语句2)
  {
    语句块
  }
```

(1）for循环开始时，会先执行语句1，而且在整个循环过程中只执行一次语句1。

(2）接着判断表达式的条件，如果条件成立，就执行一次循环体中的语句块。

(3）语句块执行完后，接下来会执行语句2。

(4）重复第2）步和第3），直到表达式的条件不成立才结束for循环。

注意：

(1）在for循环中，语句1、表达式和语句2都可以为空，for (;;)等同于while (1)。

(2）continue和break两个关键字也可以用在for循环体中。

for循环一般与计数器一起使用。例如：把1到100之间的数值累加起来。


tip:

```c
#include <stdio.h>

int main()
{
  int ii=1;      // 用于for循环的计数器
  int sum=0;     // 记录1到100的累积值

  for (ii=1;ii<=100;ii++)
  {
    sum=sum+ii;
  }

  printf("1到100的累积值为%d。\n",sum);
}
```

###### 构造死循环

```c
//1.
while(1)
{        ;
}
//2.
for(; ;)
{
       ;
}
```

----

----

----

---

---

---

## 数组和字符串

**数组是一组相同类型变量的有序集合，用于存放一组相同类型的数据。**

#### 一. 一维数组

**一维数组是用以存储一维数列中数据的集合**，由四部分组成：数组名、数据类型名、数组操作符和数组容量。

标准的定义方式为：
**==类型 数组名[常量或常量表达式];==**

**==常量或常量表达式的值规定了数组中元素的个数，即数组长度。==**

**数组一经定义，其长度就不可改变，程序编译或运行时，将为数组分配一块固定大小的、连续的储存空间。**

```
int array[4];  //将变量array定义为存储4个int型数据的数组；
char goodbyte[8];  //将变量goodbyte定义为存储8个char型数据的数组；
```

**==注意：变量不能作为数组容量的声明，下边的数组定义是错误的：==**

```c
int n = 10;
int a[n];	//n是变量，不是常量，所以错误
```

对于一位数组元素的访问，可以通过数组名、数组操作符和索引的组合进行访问，其标准形式如下：
数组变量名[索引]；

```
char bookName[6];   //访问第6个元素
```

在**数组访问**时要注意：

- 索引必须为一个值为整数的表达式，但不要求是常量表达式
- 索引的值应大于或等于0，且小于数组容量
- 数组内元素标号从0开始，直到数组容量的值减1

**推荐将数据容量以宏定义的方式写出来。**

###### 一维数组的初始化

数组的初始化就是在定义数组变量的同时给其中的数组元素赋值
**为了数据的安全，在使用数组时要对数组进行初始化。初始化方法如下：**

```
形式1：
数据类型 数组名[N] = {值0，值1，值2，……，值（N-1）};
int month[12] = {31,28,31,30,31,30,31,30,31,31,30,31};
注意：初始化的数值序列不能大于数组容量

形式2：
数据类型 数组名[N] = {值0，值1，值2};
int door[7] = {1,2,3};
int flag[10] = {0};   //将所有元素初始化为0
注意：如果只对数组的部分元素进行赋值，剩下的元素会自动初始化为0

形式3：
数据类型 数组名[] = {值0，值1，……，值n};
char font[] = {'a','b','c','d'};
注意：如果不给出数组容量大小，那么由容量中的数来决定

形式4：
指定元素初始化
int arr[6] = {[5] = 212};
```

###### **数组的存储形式**

数组元素的内存地址是连续的，其差值为数组存储的数据类型的字节长度值。如果为int型，那么数组元素的地址都相差4；如果是char型就都相差1。数组变量的值为数组的首地址。

**使用越界元素可能会由于跟其他变量的地址相同，从而改变其他变量值得情况。**

###### 数组的应用

**==冒泡排序==**

**思想（以升序排序为例）：相邻元素两两比较，将较大的数字排在后面，直到将所有数字全部排序。**

理解：第一次for循环，次数是元素个数减一。

​			第二次for循环，次数是需要比较几次才能确定最大值（除上一次for循环确定的最大值之外）。

```c
#include<stdio.h>
int main(){
    int n[10] = {1,2,3,4,5,6,7,8,9,10};
    int i,j,temp;
    for(i=1;i<10;i++){
		for(j=0;j<10-i;j++){
            if(n[j]>n[j+1]){
                temp = n[j];
                n[j] = n[j+1];
                n[j+1] = temp;
            }
        }
    }
    printf("排序过后的数的顺序");
    for(i=0;i<10;i++){
		printf("%d",n[i]);
    }
}
```

**==选择排序==**

**思想：先从N个元素中找出最小的元素，与第一个元素交换，再从剩下的N-1个元素中找出次小的元素，与第二个元素交换，以此类推，直到剩下1个数据，排序完成。**

第一趟排序开始时，ⅰ为第一个元素的下标，即假定第一个元素最小，剩余的N-1个元素都与ⅰ元素进行比较。比较中，如果有比ⅰ元素更小的数据，则用ⅰ记录这个元素的下标，与剩余的所有元素比较后，j的值就是最小元素的下标，j元素与第一个元素交换。第ⅰ趟排序，则j为第i个元素的下标，从数组中第+1个元素起到数组末尾所有元素都与j元素比较，并做与第一趟排序类似的操作，一趟排序后，即找到第ⅰ个小的数据，与数组中第i个元素交换。

```c
#include<stdio.h>
int main(){
    int a[10] = {1,2,3,4,5,6,7,8,9,10};
    int i,j,k,temp;
    for(i=0;i<9;i++){
		j=i;
        for(k=i+1;k<10；k++){
            if(a[k]<a[j]) j=k;
        }
        if(j!=i){
            temp = a[j];
            a[j] = a[i];
            a[i] = temp;
        }
    }
    for(i=0;i<10;i++){
		printf("%d",a[i]);
    }
}
```

==**通过遍历实现数组的查找**==

数组查找功能，看看是否存在该数据，如果存在并返回该元素的下标。数组元素的查找也有很多查找方式，但是我们这里可以最简单的方式，通过遍历实现数组元素的查找。

比如以下程序实现在指定数组中查找指定元素的功能，如果找到该元素返回该元素的下标，否则返回-1：

![](https://img.mukewang.com/54a91369000145eb04860500.jpg)

#### 二.  二维数组

**二维数组定义的标准形式如下：**
**类型  数组名[常量表达式1] [常量表达式2]**

```
double matrix[5][5];  //double型的5x5二维数组
int student[6][8];  //int型的6x8二维数组
```

两位维度要分别写在两个中括号内，**不能写在同一个中括号**，例如：double matrix[5,5];
对于二维数组，一维是行索引，二维是列索引。

**二维数组的存储形式**：
**存储顺序为逐行再逐列，也就是先存第一行，再第二行……**

```
形式1：
数据类型 数组名[M][N] = {值0，值1，值2，……，值（M*N-1）};
int alex[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

形式2：
数据类型 数组名[M][N] = {{(值0,0),(值0,1),(值0,2),···,(值0,(N-1))},
						{(值1,0),(值1,1),(值1,2),···,(值1,(N-1))},
						····
						{(值M-1,0),(值M-1,1),(值M-1,2),···,(值M-1,(N-1))}};
int alex[3][4] = {{0,1,2,3},
				  {4,5,6,7},
				  {8,9,10,11}};

形式3：
如果只初始化一部分元素，剩余的元素会自动置0。
int alex[3][4] = {0,1,0,0,4,5,6};
如果想全置0：
int alex[3][4] = {0};

形式4：
也可以不指定数组容量，但是只能不给出一维数组容量，而二维数组容量必须给出。
int cube[][N] = {值0，值1，……，值n};
int cube[][N] = {0,1,2};
```

**==二维数组元素引用的一般形式为==**

​	**数组名[下标1] [下标2]**

#### 三、字符数组和字符串

1. 字符数组
字符数组即char型数组，是用以存放char型数据的数组容器。其标准形式如下：
char 数组名[数组容量]

###### 用字符数组存放字符序列

```
形式1：初始化所有元素
char array[6] = {'S','u','n','d','a','y'};
char str[4] = {'g','o','o','d'};

形式2：初始化部分元素
char array[6] = {'S','u'};
char str[4] = {'g','o'};

形式3：不指定数组容量
char array[] = {'S','u'};
char str[] = {'g','o'};
```

###### 用字符数组存放字符串

**==字符串在储存时系统自动在字符序列的后面加一个ASCII码值为0的字符‘\0’作为字符串结束标记。在程序中，对字符串的操作是通过检测字符‘\0’来判断字符串是否结束的。==**

**初始化**

1. 用单个字符的方式初始化字符数组，此时，**必须有一个字符是‘\0’。**

   ```c
   char day[6] = {'T','O','d','a','y','\o'};
   ```

2. 用字符串常量对字符数组初始化

   ```c
   char ch[] = {"I am a boy"};
   ```

   或者写成

   ```c
   char ch[] = "I am a boy";
   ```

   ==注意：**这种初始化方法，字符数组ch的长度不是10，而是11.因为字符串的后面还有一个字符'\0'作为结束标志。**==

**==定义时一定要注意数组要有足够的长度容纳字符串和结束标志‘\0’。==**

**二维字符数组**
二维字符数组就是数组元素为字符的二维数组，其标准形式如下：

```
char q[3][4];
```

**二维字符数组初始化的方式与二维数组相同。**

###### 字符数组的输入/输出

**==1.逐个字符输入/输出。用字符输入函数getchar（）、字符输出函数putchar（）或格式化输入/输出函数的“%c”格式逐个字符输入/输出。==**

```c
#include<stdio.h>
int main(){
    char c[81];int i;
    for(i=0;i<80&&(c[i]=getchar())!='\n';i++);
    c[80]='\0';
    for(i=0;c[i]!='\0';i++){
		printf("%c",c[i]);
    }
}
```

程序中第一个for语句的循环体是空语句，循环从键盘读取字符赋值给数组元素c[i],并判断若不是换行符则继续读取下一个字符，直到读的字符是换行符，循环结束。

==**2.使用格式说明“%s”输入/输出字符串。**==

```c
#include<stdio.h>
int main(){
    char a[81];
    scanf("%s",a);
    printf("%s",a);
}
```

==**注意：由于使用scanf（）函数输入数据时的默认分割符是空格、制表符（Tab）、或回车，所以输入的字符串中不能含有空格和制表符（Tab）。**==

**使用scanf（）函数连续输入多个字符串时，输入的字符串之间只能用空格、制表符（Tab）或回车分隔。**

```c
char str1[10],str2[10],str3[10],str4[10];
scanf("%s%s%s%s",str1,str2,str3,str4);

```

```c
I am a boy（回车）
```

![image-20221209225500037](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221209225500037.png)

**如果将格式字符串改为"%s,%s,%s,%s",用逗号或其他字符分隔输入多个字符串，都是错误的。如果要输入含有空格或制表符(Tab)的字符串，则应使用后面介绍的字符串输入函数gets()。**

**==当执行输出语句：printf("%s",a);时，将输出字符数组中的每个字符，直到遇到一个终止符'\0'结束。==**

###### 字符串处理函数

**==字符输入/输出函数==**

预处理命令：#include<stdio.h>

1.get(字符数组名)

**其功能是从标准输入设备输入一行字符（以回车结束）储存到字符数组中，==函数返回数组的起始地址==。**

```c
char str[81];
get(str);
```

get(str)读取字符串的过程与下面的程序段等价，从中可以理解get(str)函数的功能。

```c
for(i=0;(str[i] = getchar())!='\n',i++);
str[i]='\0';
```

2.puts(字符数组名)

**==其功能是将一个字符串输出到标准输出设备，并将结束标记'\0'转换为换行。==**

**==常见的字符串处理函数==**

**==预处理命令：#Include<string.h>==**

1.  strcat(字符数组1，字符串2)

其功能是**连接两个字符串。将字符串2连接到字符数组1中串的后面，结果放在字符数组1中，函数返回字符数组1的起始地址。字符数组1应该有足够的长度，字符串2可以是字符串常量或字符数组名。**

2. strcap(字符数组1，字符串2)

**其功能是将字符串2复制到字符数组1中，==字符数组1中原来存放的内容被覆盖==，函数返回字符数组1的起始地址。字符数组1应有足够的长度，字符串2可以是字符串常量或字符数组名。**

注意：不能使用如下的赋值语句完成字符串的的复制。

```c
str = str2;
```

**==单个字符可以赋值，但字符串不能赋值，只能用strcpy()函数实现字符串复制。==**

3. strcmp(字符串1，字符串2)

**==其功能是比较字符串1和字符串2的大小，比较的结果由函数返回值带回。==**

**若字符串1>字符串2，函数值为正整数(0)；**
**若字符串1<字符串2，函数值为负整数(<0)；**
**若字符串1==字符串2，函数值为0。**
单个字符的比较是比较两个字符的ASCI码值。例如，'A的ASCI码为65，B的ASCIⅡ码为66，所以B>'A'。字符串的比较规则是：对两个字符串从左到右逐个字符相比，直到出
现不同的字符或遇到0为止，如果全部字符相同，则认为两串相等，**若出现不同的字符，则以第一个不相同字符的大小作为串的大小，函数strcmp（）的值就是这两个字符的差值。**

注意：C语言中不能使用关系运算符直接比较两个字符串

str1 \==str2		str1 >str2		**==“My” =="My"==**

这些写法都是错误的

4. strstr(字符串1，字符串2)

**该函数是子串定位函数。其功能是在字符串1中查找字符串2第一次出现的位置。若找到，则返回该位置的地址，否则返回NULL。**

5. strlen(字符串)

**其功能是求字符的长度，即字符串中字符的个数，==不包括结束标志。==**

6. strlwr(字符串)

**其功能是将字符串中的大写字母转换成小写字母。**

7. strupr(字符串)

**其功能是将字符串中的小写字母转换成大写字母。**

**==应用==**

输入一个英文句子，统计单词的个数，并将每个单词分行输出。

![image-20221210115150718](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221210115150718.png)

在字符串1中查找字符串2，确定字符串2在字符串1中第一次出现的位置。

![image-20221210120350081](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221210120350081.png)

---

---

---

---

---

---

---

## 指针

#### 内存和地址

存储器是计算机系统中的记忆元件或储存介质，用来存放程序和数据。计算机的内存储器是由许许多多的存储单元组成的，每个存储单元都有一个二进制编号，称为存储单元的地址。

#### 指针的概念

**C语言中的指针类型数据就是存放程序或数据的内存地址。**

**通过变量名和变量对应空间的地址都可以访问存储器中的数据。**

**直接访问：使用变量名访问数据的方式**

**间接访问：先把变量占用储存单元的地址存放在指针变量中，然后通过指针变量来访问变量占用的储存单元。**

**==一个变量在内存中占用储存空间的起始地址称为该变量的指针。==**

**==在数组中数组名表示数组的首地址，即(arr[0])。==**

**1.定义**

定义指针变量的一般形式为：

**==类型    *指针变量名1,\*指针变量名2;==**

**==空指针    NULL（或0）==**

**说明：**

1. **一条定义语句可以定义一个或多个指针变量。**
2. **星号（*）表示其后的变量是一个指针变量。**
3. **“类型”是指针变量的基本型，即指针所指向的变量或储存空间的类型。**

指针变量定义之后，指针变量可指向的变量（或存储空间）类型就确定了，即int型指针变量只能存储int型指针，float型指针变量只能存储float型指针。反过来，通过int型指针（或指针变量）只能访问int型空间，通过float型指针（或指针变量）只能访问float型空间。

**==指针变量中储存了变量a的指针（&a），称作p指向了a。==**

**==指针变量只有有了明确的指向，才能使用指针访问其指向的数据。==**

```c
int i,j,a[10],*p,*q;
```

```c
int a=3,*p = &a;
```

#### 指针运算

###### 取地址运算和取内容运算

**&：取地址运算符，运算对象是变量，得到变量的指针。**

**\*：指针运算符，运算对象是指针，访问指针（变量）所指向的内存空间。**

**==使用中，*p表示p保存的地址编号对应空间的内容。==**

###### 指针变量的赋值运算

**将变量的指针赋给同类型的指针变量**

```c
int i = 3;
int *p,*p1;
p = &i;
```

**将数组的起始地址赋给指针变量**

```c
p = arr;
```

**将数组arr的某个元素的地址赋给指针变量p。**

```c
p = &arr[2];
```

**==可以将一个指针变量的值赋值给另一个同类型的指针变量，此时，两个指针变量指向同一块储存空间。==**

```c
p = p1;
```

**注意事项：**

1. 指针的类型应与指针变量的类型一致

2. 可以将空指针（NULL或0）赋值给指针变量，不能用一个常量（除0外）或一个非地址表达式来给指针变量赋值。

   ```c
   p = NULL;	//正确
   p = 67	//错误
   p = i+5；	//错误
   ```

###### 指针的算数运算

- 自增自减

  - p++代表的是地址往后移动一个单位，指向下一个数据，运算后得到的还是一个指针。
  - *p++{与\*(p++)等价}代表的是地址后移之后再取出该地址下的数据，其结果是一个数据。
  - *(p)++代表将原地址中的数据取出来再加1。

- 加减整型数据：结果还是一个指针，是向前（向后）偏移所加（或减）整数个元素的指针。

- 两个指针相减

  - 这两个指针必须指向同一个数组中的元素。

  - 他们的差值即两个指针相对偏移的元素个数。

    例如：&a[1]是a[1]元素的指针，&a[1]是a[5]元素的指针，&a[5]-&a[1]的值为4。

###### 指针的比较运算

**==指向同一个数组的两个指针可以进行关系运算。==**

假设p1，p2是指向同一个数组的两个指针变量，p1指向的数组元素在p2指向的元素之前，则表达式“p1<p2”的值为1（真），否则为0（假）。当p1、p2指向数组的同一元素时，p1 ==p2为真，否则为假。

#### 数组中的指针

**==由于数组元素在内存中连续存放，知道一个元素的指针，就可以通过加减运算求得其他元素的指针。==**

**==C语言规定，一维数组名是一个指针常量，代表数组再内存中的起始地址，准确地说是数组0元素的指针。==**

###### 一位数组中的指针

对数组访问的两种方法：

==**下标法**==

==**指针法**==

1.通过取地址运算符求得元素的指针

```c
#include<stdio.h>
int main(){
    int a[10],i;
    for(i=0;i<10;i++){
        scanf("%d",&a[i]);	//&a[i]是数组元素a[i]的指针
    }
}
```

2.通过数组0元素的指针a加i求得元素的指针。

```c
#include<stdio.h>
int main(){
    int a[10],i;
    for(i=0;i<10;i++){
        scanf("%d",a+i);	//&a[i]是数组元素a[i]的指针
    }
}
```

3.使用指向数组元素的指针变量

```c
#include<stdio.h>
int main(){
    int a[10],*p;
    p = a;
    for(;p<(a+10);p++){
        scanf("%d",p);
    }
}
```

**或者**

```c
#include<stdio.h>
int mian(){
    int a[10],i,*p;
    p = &a[0];
    for(i = 0;i<10;i++){
        scanf("%d",p+i);
    }
}
```

**==指针变量可以自增自减，而数组名不可以自增自减。==**

###### 二维数组中的指针

```c
int x[3][4];
```

x数组可视作由元素x[0]~x[2]组成的一维数组，x[0]~x[2]本身有是一个一维数组，x是x

[0]的指针，x[0]是x[0] [0]的指针，x[1]是x[1] [0]的指针，x[2]是x[2] [0]的指针。

**==使用二维数组元素指针访问数组元素==**

方法一：通过二维数组每行的首地址（x[i]）访问二维数组的元素。

```c
#include<stdio.h>
int main(){
    int x[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}},i,j;
    for(j = 0;j<4;j++){
        printf("%3d",*(x[i]+j));
    }
}
```

方法二：通过指向二维数组元素的指针变量访问二维数组元素。

```c
#include<stdio.h>
int main(){
    int x[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}},i,j，*p;
    p = &x[0][0];	//等价于p = x[0];
    for(i = 0;i<3;i++){
        for(j = 0;j<4;j++){
        	printf("3d",*p++);
        }
        printf("\n");
    }
}
```

**==使用二维数组的行指针访问数组元素==**

**在上面的示例中，&x[i]、x+i是i行4个元素整体所使用内存空间的起始地址，是行指针。这样的指针应储存在指向行的指针变量中**

指向行的指针变量定义形式：

类型（*指针变量名）[m];

**==x是x[0]的指针，x+i是元素x[i]的指针，*(x+i)是x[i],x[i]+j是元素x[i] [j]的指针，所以\*(x+i)+j是元素x[i] [j]的指针，\*（\*(x+i)+j）就是数组元素x[i] [j]。==**

方法一：通过二维数组名x访问二维数组的元素

```c
#include<stdio.h>
int main(){
    int x[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}},i,j;
    for(j = 0;j<4;j++){
        printf("%3d",*(*(x+i)+j));
    }
}
```

方法二：通过指向二维数组行的指针变量访问二维数组元素。

```c
#include<stdio.h>
int main(){
    int x[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}},i,j;
    for(j = 0;j<4;j++){
        printf("%3d",*(x[i]+j));
    }
}
```

####   用指针处理字符串 

###### 用字符指针指向字符串常量

**形式**

```c
char *p = "I love you";
```

```c
char *p;
p = "I love you";
```

这两种方式的本质都是将字符串第一个字符的地址赋值给字符型指针变量。

###### 字符串的引用方式

==**通过字符数组名或指向字符串的字符指针两种方法应用字符串**==

**通过字符数组名引用字符串**

```c
#include<stdio.h>
int main(){
    char a[20] = "Do you know?";
    puts(a);
    printf("%s",a);
}
```

**通过字符指针指向字符串的方式引用字符串。**

```c
#include<stdio.h>
void main(){
    char *str1 = "I love you",str2;
    str2 = "love";
    printf("%s %s",str1,str2);
    puts(str1);
    puts(str2);
}
```

#### 指针数组和指针的指针

###### 指针数组

**==由指向同一数据类型数据的指针作为元素组成的数组称为指针数组。==**

**定义格式：**

**类型  *数组名[数组长度];**

```c
int *num[5];
```

**==指针数组经常使用在字符串的处理中==**

**==采用指针数组存储字符串时，字符串在内存中可按实际长度存放==**

（若用二维数组存放字符串，则每个字符串都占用等长的存储空间）

```c
char *str[3] = {"one","programming","ok"};
```

```c
char *str[3];
str[0] = "one";
str[1] = "programming";
str[2] = "ok";
```

###### 指向指针的指针

**指针变量也要分配内存空间，指针变量的地址称为指针的指针**

二级指针变量定义的一般形式为：

**类型  \**标识符;**

```c
char **p;
```

使用指针的指针

![image-20221212225540892](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221212225540892.png)

利用二级指针存取二维数组的元素

![image-20221212225554429](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221212225554429.png)

---

---

---

---

---

---

## 函数

#### 函数的定义、调用和声明

###### 函数定义

**根据功能需求，按照函数定义格式，从无到有编写一个函数的过程，即函数定义。**

**函数定义的一般形式为：**

**函数类型  函数名（类型1  形式参数1，类型2  形式参数2，...）**

**{**

​	**说明部分**

​	**可执行语句序列**	

**}**

1. 第一行称为函数首部（或函数头），包括三方面内容：函数类型、函数名和形式参数表。函数首部之后的大括号中的内容称为函数体，由两部分内容组成：说明部分和可执行语句序列。
2. 函数首部的函数类型指明了函数返回值的类型。可以是基本类型、空类型和指针类型，也可以是后续章节中的结构体或共用体类型。如果没有指明类型，则默认为整型。若函数名前带有星号(*)，则函数的类型为指针类型。函数的返回值由return语句返回。
3. 函数名是函数的唯一标志，用于区别不同的函数，必须是合法的标识符。
4. 函数名后圆括号中的部分称为形式参数列表，是用逗号分隔的形参变量的定义。 

**==函数的返回值==**

函数被调用后，执行函数体中的程序段所取得的，并返回给主函数的值。

return语句的一般形式为：

​		**return  表达式；**

**注意：**

1. **函数一旦遇到return语句就立刻返回，后面的语句均不会执行。**

   **return语句有强制结束函数执行的作用。**

2. 函数值的类型和函数定义的类型应保持一致。如果二者不一致，则以函数返回类型为准，自动进行类型转换。

3. 没有函数值的函数，返回值为void（空）。void中若有return;只表示结束函数运行。

###### 函数调用

**写出函数名且在其后的圆括号中给出具体的数据的过程称为函数调用。**

函数调用出现在主调函数的函数体中。在主调函数执行到函数调用时，就转去执行相应的被调函数，被调函数执行结束后返回到主调函数，继续执行主调函数中的后继语句。

**函数调用作为表达式的一部分**

```java
y = division(x,y);	//将函数调用division(x,y)的返回值赋值给变量y
```

**函数调用作为独立的一条语句，在函数调用后加分号。**

```java
division(x,y);	//调用函数
```

**函数调用作为函数的实参，返回值参与实参表达式的计算**

```java
y = max(c,max(a,b));	//求a,b,c三个数中的最大值
```

###### 函数声明

1. 调用库函数时，不需要对函数进行声明，而是在开头用#include命令将对应的扩展名为.h的头文件包含进来。
2. **如果要使用用户自定义的函数，并且函数定义的位置在主调函数之后，则需要在主调函数的开始部分对被调函数进行声明。**

函数声明的一般形式为：

**函数类型  函数名（类型1  形式参数1，类型2  形式参数2，...）;**

---

#### 函数参数及其传递方式

###### 函数的参数

**形参：**定义函数名和函数体时使用的参数，目的是用来接收调用该函数时传入的参数。只有在函被调用时才分配内存，只在函数内部有效，函数调用结束返回主调函数后则不能使用该形参变量。

**实参：**在调用时传递该函数的参数。在进行函数调用前必须获得确定的值。可以是常量、变量、表达式、函数调用等。

**==形参和实参在数量上、类型上、顺序上应相同或赋值兼容==**

**==函数调用中发生的数据传送是单向的。即只能把实参的值传送给形参变量，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，不会影响实参。==**

###### 函数参数的传递方式

**==值传递==**

**==形参变量是普通变量（非指针变量）时，参数的传递即值传递==。将实参表达式的值赋值给形参变量，被调函数中形参的改变对调用时的实参没有影响。==在被调函数体中，不能访问主调函数中的变量；在主调函数体中，也不能访问被调函数中的变量。==**

**==地址传递==**

**==当形参变量为指针类型时，实参与新参之间的值是地址传递。调用函数时，实参应该是主调函数中变量的指针或数组的首地址。==**将实参指针传递给新参变量后，被调函数中的形参变量指向主调函数中的变量或数组，**==在被调函数中通过该指针形参变量可以访问主调函数中的变量或数组元素。==**

1.指针形参

当指针作为函数参数时，实参和形参都为指针类型。在函数调用时，将实参指针传递给形参指针。**在被调函数的函数体中，通过形参指针间接访问主调函数中的变量。**

**交换主调函数中两个变量的值**

```c
#include<stdio.h>
int swap(int *a,int *b);
int main(){
    int x = 2,y = 3;
    swap(&x,&y);
}
int swap(int *a,int *b){
    int t;
    t = *a;
    *a = *b;
    *b = t;
}
    
```

2.数组形参

**数组作为函数的参数，其本质与指针作为参数是一样的。当函数的形参为数组时，实参应该是数组名，**将实参数组的首地址传给形参，形参数组与实参数组共用一块内存空间，即主调函数中数组的空间

```java
int func(int x[],int n){}
//等价于
int func(int *x,int n){}
```

**上面的两个形参变量x实际上都是指针形参，在函数中==既可以作为数组名使用，也可以作为指针变量使用。==**

**求一个整型数组前n个元素的乘积**

```c
#include<stdio.h>
int pro1(int arr[],int n);
int pro2(int *arr,int n);
int main(){
    int a[10] = {1,2,3,4,5,6,7,8,9,10};
    int p1,p2;
    p1 = pro1(a,10);
    p2 = pro2(a,10);
}
int pro1(int arr[],int n){
    int i;
    int p = 1;
    for(i = 0;i<n;i++){
		p*=arr[i];		
    }
    return(p);
}
//两个函数等价
int pro2(int *arr,int n){
    int i;
    int p = 1;
    for(i = 0;i<n;i++){
        p*=arr[i];
    }
    return(p);
}
```

就参数传递而言，地址传递与值传递没有区别，都是将实参的值（普通值或地址值)赋值给形参变量。但从数据访问来看，由于**地址传递的是主调函数中变量的地址，通过该地址可以在被调函数中间接访问主调函数中的变量；而值传递与主调函数之间没有访问变量的通道。**

###### 函数的参数

**形参：**定义函数名和函数体时使用的参数，目的是用来接收调用该函数时传入的参数。只有在函被调用时才分配内存，只在函数内部有效，函数调用结束返回主调函数后则不能使用该形参变量。

**实参：**在调用时传递该函数的参数。在进行函数调用前必须获得确定的值。可以是常量、变量、表达式、函数调用等。

#### 变量的作用域规则与存储类别

形参变量只在被调用期间才分配内存单元，调用结束后立即释放。这一点表明**形参变量只有在函数内才是有效的，离开该函数就就不能再使用了。这种变量有效性的范围称为变量的作用域。**

**==所有的变量都有自己的作用范围。在这个范围内程序可以访问该变量，即可以对该变量赋值或使用该变量的值，离开了这个范围，该变量或者不能访问，或者不存在。变量的作用域取决于变量的定义位置，按变量的作用域范围可分为两种，即局部变量和全局变量。==**

###### 局部变量和全局变量

**==局部变量==**

在函数内部定义的变量是局部变量，它只在本函数范围内有效，即**==局部变量的作用域是变量定义所在的函数内==。**局部变量又称内部变量。因此，**在不同的函数内可定义同名的局部变量，这些同名变量之间不会发生冲突。**

**==main()函数中定义的变量也只在主函数中有效。因为main函数也是一个函数，与其他函数定义平行。==**

**==全局变量==**

**==在所有函数（包括main（）函数）之外定义的变量称为全局变量。==全局变量不属于任何函数，其==作用域是从定义的位置开始到本源程序文件结束。==**

**在同一个源程序中，全局变量和局部变量可以同名，在局部变量的作用域内，同名的全局变量被屏蔽。**

###### 变量的储存类别

**变量和函数都有两种属性：数据类型和储存类别。**

**==储存类别  数据类型  变量名表：==**

```c
auto int a,b,c;		//定义自动整型变量a,b,c
static int x,y,z;		//定义静态整型变量x,y,z
register int i,j,k		//定义寄存器整型变量i,j,k
```

**==变量的储存类别是指变量使用储存资源（内存和寄存器）的方式。==**

- **auto（自动储存类型）**
- **static（静态储存类型）**
- **register（寄存器储存类型）**
- **extern（外部储存类型）**

![image-20221230092238077](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221230092238077.png)

**程序区储存程序代码。静态储存区和动态储存区存放程序处理的数据。变量的储存类别分为静态储存和动态储存两类，指定了为变量分配内存空间的方式及使用内存空间的位置。**

**静态储存方式是在程序运行前分配固定储存空间的方式，即在程序开始运行前分配空间，整个程序运行结束后才释放空间：例如：全局变量就属于这种储存方式。而动态储存方式则是在程序的运行期间进行动态分配和释放储存空间，即运行时分配空间，运行结束后释放空间，同一个空间在程序运行的不同时间可以分配给不同的变量。例如函数的形参就属于这种储存方式。**



**==自动变量==**

自动储存类型变量是最常用的一种储存类型，**属于动态存储，在函数内部或复合语句内部定义的变量默认是自动存储类型，函数形参变量也是自动储存类型。**

**自动变量的作用域是其所在的函数内或复合语句内。函数被调用时分配空间，返回时则释放空间。**

**形式：**

**auto 数据类型 变量名1，变量名2，变量名n;**

==实际上，程序中大多数变量都属于自动变量，且关键字auto可省略，前面介绍的函数中定义的变量都没有声明为auto，起始都隐含指定为自动变量==



**==静态变量==**

**形式：**

**static  数据类型  变量名1，变量名2，...，变量名n;**

**==静态型储存变量属于静态储存，又可分为静态局部变量和静态全局变量==**

- **静态局部变量**

**如果希望函数中的局部变量值在函数调用结束后不消失而保留原值，即它占用的存储单元不释放，在下次调用该函数时，其局部变量还是上次函数调用结束时的值，这时就需要将该局部变量声明为“静态局部变量”**

==当在局部变量名前加上静态变量说明符static时，编译程序将为该变量建立永久存储单元，在函数调用结束后不释放内存单元，而保留原值，下次再调用该函数时，以该变量上次调用结束时的值参加运算。==

- **静态全局变量**

在全局变量定义的类型名前加上static，可定义一个静态全局变量。**静态全局变量与普通全局变量相似**，是一种公用的全局变量，**采用静态储存方式，但作用域不同。静态全局变量仅限于在定义它的源文件内引用，在同一个c程序的其他源文件中不能引用。**

**在源文件1中定义了一个静态全局变量a，此变量仅能在此文件中使用，在源文件2中不能使用。如删除静态变量定义static，源文件2则可以使用源文件1中的变量，但需要用extern声明**

**总的来说，当c程序由一个源文件构成时，普通全局变量和静态全局变量是没有区别的。当c程序由多个源文件构成时，全局变量与静态全局变量则含义不同，静态全局变量只能在自身的程序中被应用**



**==寄存器变量==**

**形式:**

**register 数据类型 变量名1，变量名2，变量名n;**

**使用寄存器变量比使用内存变量速度快的多。因为这种变量使用CPU中的寄存器，不需要访问内存。**

==在程序中，不必专门使用寄存器变量==



**==外部变量==**

**extern 用来申明外部变量，就是声明一些在别处定义的全局非静态变量在此处使用。**

**形式：**

**extern  数据类型  变量名1，变量名2，变量名n;**

**extern的作用不是定义新的变量，不为变量分配空间，而是扩展已定义的全局变量的作用域。**

**情况1：在一个源程序中提前使用后面定义的全局变量，需要在使用前用extern申明。**

![image-20221230105729295](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221230105729295.png)

**情况2：在当前源程序文件中要引用同一个c程序的其他源程序中的非静态全局变量，也需要在使用前用extern声明。**

![image-20221230110850162](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221230110850162.png)

###### 内部函数和外部函数

**根据函数能否被其他源文件调用，可将函数分为内部函数和外部函数。**

**==内部函数（静态函数）==**

**如果在一个源文件中定义的函数，只能被本文件中的函数调用，而不能被同一C程序的其他文件中的函数调用，这种函数称为内部函数。定义时，在函数名前加static即可。**

**形式：**

**static 类型 函数名（形参名）**

**这样，函数就不能被程序中的其他源文件调用了，此处的static不是指存储方式，而是对函数的作用域仅局限于本文件。内部函数定义时，关键字static一定不能省略。**

**==外部函数==**

**形式：**

**[exterm]  类型  函数名（形参列表）**

**extern可省略**

![image-20221230112845935](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20221230112845935.png)

---

---

---

---

---

## 结构体

![](https://img-blog.csdn.net/20151108132423684)

**结构体是若干数据元素的聚集，它的数据元素的数据类型可以不同。结构体中的数据元素又称结构体的成员。**

#### 结构体类型定义

==定义学生结构体类型==

![image-20230211222640257](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230211222640257.png)

**==结构体类型定义的一般形式为：==**

**struct  结构体名**

**{**

​	**类型1  成员名1；**

​	**类型2  成员名2；**

​	**类型n  成员名3；**

**}；**

==结构体各个成员的数据类型可以是任意类型，包括基本数据类型或结构体类型，**甚至可以是结构体类型本身**==

**==结构体类型嵌套定义：==**

![image-20230211223324812](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230211223324812.png)

#### 结构体类型变量、数组和指针的定义

定义日期结构体类型：

![image-20230211223651122](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230211223651122.png)

**定义该结构体变量：**

**struct date yesterday,today,tomorrow;**

其中：struct date是前面定义的日期类型，yesterday，today，tomorrow是这种结构体的变量。

**按照一个int型数据占两个字节，日期类型变量today内存分配示意图如下**

![image-20230211225005876](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230211225005876.png)

**==结构体类型数据占用内存空间的字节数是结构体中每个成员所占字节数之和。==**

同样可以定义结构体类型数组，指针

**struct  date  d[10],*pd;**

**d为结构体数组，该数组有10个元素，元素类型是struct date，该数组可以储存10个日期数据；pd是指向struct date类型数据的指针变量，可以指向yesterday，today，tomorrow或数组d的元素等struct date类型变量。**

###### 结构体类型变量，数组，指针的定义

**（1）先定义结构体类型，再定义结构体变量**

![image-20230211231020784](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230211231020784.png)      

**（2）定义结构体类型，同时定义结构体变量**

![image-20230211231123065](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230211231123065.png)

**（3）定义无名结构体类型，同时定义结构体变量。**

![image-20230211231305676](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230211231305676.png)

**（4）先用typedef语句定义类型标识符，再用类型标识符定义变量**

![image-20230212104022506](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212104022506.png)

![image-20230212104109008](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212104109008.png)

#### 结构体类型变量，数组和指针的初始化

###### 在定义结构体变量的同时为变量赋一个初值

![image-20230212104312613](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212104312613.png)

**==结构体变量的初始化数据要用大括号括起来，大括号中的常量数据用逗号隔开，依次初始化对应的成员。==**

![image-20230212104610761](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212104610761.png)

![image-20230212104817122](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212104817122.png)

#### 结构体类型变量的引用

**可以整体引用结构体变量，也可以只引用结构体变量的成员。**

**==只有在同类型结构体变量之间赋值时，结构体变量才可以整体引用，其他情况则只能引用结构体变量的成员。==**

![image-20230212105156415](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212105156415.png)

![image-20230212105211823](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212105211823.png)

结构体成员的引用有两种形式：一是使用"."运算符，通过结构体变量名引用结构体的成员；二是使用"->"运算符，通过指向结构体数据的指针你引用结构体的成员。

###### 通过"."运算符引用

"."是结构体成员的访问运算符，用结构体变量访问其成员的一般形式如下：

**==结构体变量名 . 成员名==**

例如:

![image-20230212105857040](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212105857040.png)

其中，today.year引用结构体变量today的year成员，其他类似。

![image-20230212110029856](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212110029856.png)

**如果结构体是嵌套定义的，则用"."运算符逐级引用。**例如，person结构体中birthday成员的类型是结构体类型date，可以使用以下方法引用结构体变量w1的birthday的成员：

![image-20230212110305952](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212110305952.png)

![image-20230212110456795](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212110456795.png)

**=="."运算符的优先级在所有C语言的运算符中最高。==**

###### 通过"->"运算符引用

**=="->"是指向结构体成员运算符，用结构体指针访问所指结构体成员，一般形式如下==**

**==结构体指针变量名 -> 成员名==**

**"->"由连续的两个字符"-"和">"组成。与"."运算符不同的是，"->"运算符用来访问结构体指针所指向的结构体数据的成员。**

**"->"运算符的优先级与"."运算符的优先级是相同的，也是优先级最高的运算符**

![image-20230212111533420](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212111533420.png)

**==举例212页==**

#### 结构体指针与函数

**C语言函数的参数传递都是传值的，一些应用程序需要用结构体数据作为参数进行传递。**

**函数之间如果需要传递结构体数据，一般采用传递结构体指针的方法**这样就大幅减少了参数传递时候的数据传送量。，也意味着程序运行速度得以提高。

**函数返回时道理也一样，在结构体的字节数比较多时，应该尽量避免返回一个结构类型的数据，而尽可能返回一个指向结构体的指针变量。**

###### 指向结构体的指针变量作为函数参数

函数间传递结构体数据时，函数参数可以是结构体变量的成员，也可以是结构体变量，还可以是指向结构体的指针。

**常见的做法是将指向结构体的指针作为函数的实参，传递给调用的函数。这种传递的方式相当于地址传递，指针形参变量和实参指针指向同一内存空间。**

**==需要注意的是，采用这种参数传递方式，在被调用的函数中如果对结构体成员进行赋值，则会改变上一级函数中结构体变量的值。==**

【例7-5】某学校增加教师的工资。假设工资根据教师的职称增加：教授增加500元，副教授增加300元，讲师增加200元，助教增加100元。教师的信息有姓名、年龄、职称和工资等，编写程序，计算每位教师增加后的工资（假设共有100位老师）。
分析：教师的基本信息包括：name(姓名)、age(年龄)、post(职称)和wages(工资)。
采用结构体类型存储基本信息。增加工资用add()函数实现，实参和形参采用指向结构体
类型的指针。

![image-20230212214959737](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212214959737.png)

![image-20230212215012728](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212215012728.png)

![image-20230212215035837](https://wangmingjie1.oss-cn-zhangjiakou.aliyuncs.com/image-20230212215035837.png)

###### 函数返回结构体指针

**==函数的返回值可以是一个结构体指针，即结构的首地址，用来实现函数间的数据的传递。这是一种高效的数据传递。==**

**返回结构体指针函数定义的一般形式为：**

**struct  结构体名  *函数名（形参表）**

```
//如下定义了一个函数func，该函数返回指向结构体person的指针。需要注意的是，接收返回值的变量必须与调用的函数具有相同类型的结构体指针变量
struct person *func(int x,int y){...}
```

示例:p217页
